""" display probabilities generated by models """

from __future__ import print_function

import os.path
from collections import defaultdict
from Orange.classification import Classifier

from attelo.edu import mk_edu_pairs

from .decode import select_fold, select_doc

from ..args import add_common_args, add_learner_args,\
    add_fold_choice_args, args_to_phrasebook
from ..decoding import DataAndModel
from ..io import read_data, load_model

RELS = ('Acknowledgement', 'Alternation', 'Background',
'Clarification_question', 'Comment', 'Conditional', 'Continuation', 'Contrast',
'Correction', 'Elaboration', 'Explanation', 'Narration', 'Parallel', 'Q-Elab',
'Question-answer_pair', 'Result')

# These can probably be imported from .decode too
def _select_data(args, phrasebook):
    """
    read data into a pair of tables, filtering out training
    data if a fold is specified

    NB: in contrast, the learn._select_data filters out
    the test data
    """

    data_attach, data_relate =\
        read_data(args.data_attach, args.data_relations,
                  verbose=not args.quiet)
    if args.fold is not None:
        data_attach, data_relate =\
            select_fold(data_attach, data_relate,
                        args, phrasebook)
    return data_attach, data_relate

def _load_data_and_model(phrasebook, args):
    """
    Return DataAndModel pair for attachments and relations
    """
    data_attach, data_relate = _select_data(args, phrasebook)
    model_attach = load_model(args.attachment_model)
    attach = DataAndModel(data_attach, model_attach)
    if data_relate is not None:
        model_relate = load_model(args.relation_model)
        relate = DataAndModel(data_relate, model_relate)
    else:
        relate = None
    return attach, relate
# -- end of copy-pasted stuff

def _write_attach_probs(dir_path, prefix, doc_name, probs, order):
    """ Create probability table for attachment"""
    sform = '{0:.2f}' if prefix == 'pred' else '{0}'
    filename = os.path.join(dir_path, prefix,
                        '{0}.attach.dat'.format(doc_name))
    with open(filename, 'w') as f:
        print(':'.join(order), file=f)
        for u in order:
            print(':'.join(sform.format(probs[u][v])
                for v in order), file=f)

def _write_rel_probs(dir_path, prefix, doc_name, probs, order):
    """ Create probability table for relations """
    sform = '{0:.2f}' if prefix == 'pred' else '{0}'
    filename = os.path.join(dir_path, prefix,
                        '{0}.rel.dat'.format(doc_name))
    with open(filename, 'w') as f:
        print(' '.join(order), file=f)
        print(':'.join(RELS), file=f)
        for u in order:
            print(' '.join(
                    ':'.join(sform.format(probs[u][v][r])
                        for r in RELS)
                    for v in order), file=f)

def config_argparser(psr):
    """ Arguments for subcommand """
    add_common_args(psr)
    add_fold_choice_args(psr)
    # Not useful until we do more than one fold
    # add_learner_args(psr)
    psr.add_argument("--attachment-model", "-A", default=None,
                     required=True,
                     help="model needed for attachment prediction")
    psr.add_argument("--relation-model", "-R", default=None,
                     help="model needed for relations prediction")
    psr.add_argument('--output', '-o', metavar='DIR', required=True,
                    help='save probabilities here')

    psr.set_defaults(func=main)

def main_for_harness(args, phrasebook, attach, relate):
    """ Main with precomputed args """

    # Retrieve all document names
    grouping_index = attach.data.domain.index(phrasebook.grouping)
    all_groupings = frozenset(inst[grouping_index].value for
                              inst in attach.data)

    for doc_name in all_groupings:
        doc_attach, doc_relate = select_doc(phrasebook, doc_name, attach, relate)

        # Attachment
        tab_attach = defaultdict(lambda:defaultdict(float))
        tab_true_attach = defaultdict(lambda:defaultdict(int))
        edu_starts = dict()
        edu_pair = mk_edu_pairs(phrasebook, doc_attach.data.domain)
        i = j = 0
        for inst in doc_attach.data:
            i += 1
            edu1, edu2 = edu_pair(inst)
            edu_starts[edu1.id] = edu1.start
            edu_starts[edu2.id] = edu2.start
            probs = doc_attach.model(inst, Classifier.GetProbabilities)
            prob = probs['True'] if 'True' in probs.keys() else 0.
            act = 1 if inst['CLASS'] == 'True' else 0
            tab_attach[edu1.id][edu2.id] = prob
            tab_true_attach[edu1.id][edu2.id] = act

        order = sorted(edu_starts, key=lambda k:edu_starts[k])
        _write_attach_probs(args.output, 'pred', doc_name, tab_attach, order)
        _write_attach_probs(args.output, 'ref', doc_name, tab_true_attach, order)

        # Relations
        tab_rel = defaultdict(lambda:defaultdict(lambda:defaultdict(float)))
        tab_true_rel = defaultdict(lambda:defaultdict(lambda:defaultdict(int)))
        for inst in doc_relate.data:
            edu1, edu2 = edu_pair(inst)
            probs = doc_relate.model(inst, Classifier.GetProbabilities)
            for rel in RELS:
                prob = probs[rel] if rel in probs.keys() else 0.
                tab_rel[edu1.id][edu2.id][rel] = prob
            act = inst['CLASS'].value
            tab_true_rel[edu1.id][edu2.id][act] = 1
        _write_rel_probs(args.output, 'pred', doc_name, tab_rel, order)
        _write_rel_probs(args.output, 'ref', doc_name, tab_true_rel, order)

def main(args):
    """ Subcommand main """
    phrasebook = args_to_phrasebook(args)
    attach, relate = _load_data_and_model(phrasebook, args)
    main_for_harness(args, phrasebook, attach, relate)
